" Modeline {
" Rules only for this file
" vim: set sw=4 ts=4 sts=4 et tw=78 foldmarker={,} foldlevel=0 foldmethod=marker spell:
" }

" Environment {

    " Identify platform {
        silent function! MAC()
            return has('macunix')
        endfunction
        silent function! LINUX()
            return has('unix') && !has('macunix') && !has('win32unix')
        endfunction
    " }

    " Basics {
        " Do not need to think about vi and warding off unexpected things
        set nocompatible
    " }

    " This section could include Windows or Linux compatibility solutions

" }

" Plugins {

    " Extended % matching
    runtime macros/matchit.vim

    if filereadable(expand("~/.vim/vimrc.plugins"))
        source ~/.vim/vimrc.plugins
    endif

    " NERDTree {

        " Toggle NERDTree with a shortcut
        nnoremap <silent> <C-n> :NERDTreeToggle<CR>

        " Close NERDTree when it is the only open pane
        autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif

        " Like vim-vinegar, open the current directory when pressing "-"
        nnoremap <silent> - :silent edit <C-R>=empty(expand('%')) ? '.' : expand('%:p:h')<CR><CR>

        " When hitting "-", can hit C-^ to return to file
        let g:NERDTreeCreatePrefix='silent keepalt keepjumps'

        " Select last file when opening NERDTree
        if has('autocmd')
            augroup JoosepNERDTree
                autocmd!
                autocmd User NERDTreeInit call autocmds#attempt_select_last_file()
            augroup END
        endif

    " }

    " Fzf {
        
        if MAC()
            " Search files with Ctrl-p
            nnoremap <silent> ∏ :call FZFOpen(':Files')<CR>
     
            " Search for tags with Ctrl-g
            nnoremap <silent> ˝ :call FZFOpen(':Tags')<CR>

            " Search all files' contents with ctrl f
            nnoremap <silent> Ï :call FZFOpen(':Ag')<CR>

            " Search buffers by file name with ctrl e
            nnoremap <silent> ´ :call FZFOpen(':Buffers')<CR>

            " Search commands with ctrl a
            nnoremap <silent> Å :Commands<CR>
        elseif LINUX()
            " Search files with Ctrl-p
            nnoremap <silent> <C-p> :call FZFOpen(':Files')<CR>
     
            " Search for tags with Ctrl-g
            nnoremap <silent> <C-g> :call FZFOpen(':Tags')<CR>

            " Search all files' contents with ctrl f
            nnoremap <silent> <C-f> :call FZFOpen(':Ag')<CR>

            " Search buffers by file name with ctrl e
            nnoremap <silent> <C-e> :call FZFOpen(':Buffers')<CR>

            " Search commands with ctrl a
            nnoremap <silent> <C-a> :Commands<CR>
        endif
       
        " Open small file preview while searching files
        command! -bang -nargs=? -complete=dir Files
                    \ call fzf#vim#files(<q-args>, fzf#vim#with_preview(), <bang>0)
        command! -bang -nargs=? -complete=dir Ag
                    \ call fzf#vim#ag(<q-args>, fzf#vim#with_preview(), <bang>0)
        
        " Customize fzf colors to match the color scheme
        let g:fzf_colors =
          \ { 'fg':      ['fg', 'Normal'],
            \ 'bg':      ['bg', 'Normal'],
            \ 'hl':      ['fg', 'Comment'],
            \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
            \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
            \ 'hl+':     ['fg', 'Statement'],
            \ 'info':    ['fg', 'PreProc'],
            \ 'border':  ['fg', 'Ignore'],
            \ 'prompt':  ['fg', 'Conditional'],
            \ 'pointer': ['fg', 'Exception'],
            \ 'marker':  ['fg', 'Keyword'],
            \ 'spinner': ['fg', 'Label'],
            \ 'header':  ['fg', 'Comment'] }

    " }

    " Lightline {
    
        " Configure lighline set up
        let g:lightline = {
          \ 'colorscheme': 'Dracula',
          \ 'active': {
          \   'left': [ [ 'mode', 'paste' ],
          \             [ 'gitbranch', 'readonly', 'filename', 'modified' ] ],
          \   'right': [ [ 'linter_checking', 'linter_errors', 'linter_warnings' ],
          \              [ 'percent' ],
          \              [ 'filetype' ],
          \              [ 'gutentags' ],],
          \ },
          \ 'component_function': {
          \   'gitbranch': 'fugitive#head',
          \   'gutentags': 'gutentags#statusline',
          \ },
          \ 'component_expand': {
          \   'linter_checking': 'lightline#ale#checking',
          \   'linter_warnings': 'lightline#ale#warnings',
          \   'linter_errors': 'lightline#ale#errors',
          \ },
          \ 'component_type': {
          \     'linter_checking': 'left',
          \     'linter_warnings': 'warning',
          \     'linter_errors': 'error',
          \ },
          \ }

        " Use font awesome glyphicons for indicators
        let g:lightline#ale#indicator_warnings = "\uf071"
        let g:lightline#ale#indicator_errors = "\uf05e"

    " }
    
    " ALE {
    
        " Fixing
        let g:ale_fix_on_save = 1
        let g:ale_fixers = {
                    \   'javascript': ['eslint'],
                    \   'javascript.jsx': ['eslint'],
                    \}

        " Use eslint_d for faster linting
        let g:ale_javascript_eslint_executable = 'eslint_d'

        " Autofix entire buffer with eslint_d:
        nnoremap <leader>f mF:%!eslint_d --stdin --fix-to-stdout<CR>`F
        " Autofix visual selection with eslint_d:
        vnoremap <leader>f :!eslint_d --stdin --fix-to-stdout<CR>gv

    " }

    " Javascript {

        let g:javascript_plugin_jsdoc = 1
        let g:javascript_plugin_flow = 1
    
    " }

    " JSX Pretty {

        let g:vim_jsx_pretty_colorful_config = 1

    " }
    
    " DevIcons {{{

        let g:WebDevIconsUnicodeDecorateFolderNodes = 1

    " }}}

    " UltiSnips {

        " Directories to store snippets in
        let g:UltiSnipsSnippetsDir = "~/.vim/snips"
        let g:UltiSnipsSnippetDirectories = ["UltiSnips", "snips"]

        " Trigger configuration
        " let g:UltiSnipsExpandTrigger='<leader>e'
        let g:UltiSnipsJumpForwardTrigger='<tab>'
        let g:UltiSnipsJumpBackwardTrigger='<s-tab>'

        " :UltiSnipsEdit in new split
        let g:UltiSnipsEditSplit="vertical"

    " }

    " Deoplete {

        " Enable deoplete on startup
        let g:deoplete#enable_at_startup = 1       
        " Autocomplete file names from buffer and not the opened directory
        let g:deoplete#file#enable_buffer_path = 1
        
        " Enable full fuzzy matching. Not sure what it does to be honest, but
        " fuzziness is nice. The default is standard "fuzzy" matching. Seems to 
        " give better results.
        call deoplete#custom#source('_', 'matchers', ['matcher_full_fuzzy'])

    " }

    " LanguageClient {

        " Automatically start language servers
        let g:LanguageClient_autoStart = 1

        nnoremap <F5> :call LanguageClient_contextMenu()<CR>

    " }

    " Startify {

        " Set bookmarks
        let g:startify_bookmarks = [{ 'd': '~/.dotfiles/' }]

        " Change directory to git root on item select
        let g:startify_change_to_vcs_root = 1

        " Show DevIcons in the list of files
        function! StartifyEntryFormat()
            return 'WebDevIconsGetFileTypeSymbol(absolute_path) ." ". entry_path'
        endfunction

        " Use cursorline
        autocmd User Startified setlocal cursorline

    " }

" }

" General {

	set background=dark

	" Automatically detect file types and set indentation
	filetype plugin indent on
	" Syntax highlighting
	syntax on

    " Enable mouse usage
    set mouse=a
    " Hide cursor when starting to type
    set mousehide

	" Integration with the system clipboard
	if has('clipboard')
		if has('unnamedplus')
			" When possible, use the + register for copy/paste
			set clipboard=unnamed,unnamedplus
		else
			" On Mac and Windows, use the * register
			set clipboard=unnamed
		endif
	endif

    " Longer history
	set history=1000
	" Buffer switching without saving
	set hidden

	" Spell checking
	set spell

	" Setting up directories {
		" Set backups to be written into temp folders
		set backup
		set backupdir=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
		set backupskip=/tmp/*,/private/tmp/*
		set directory=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
		set writebackup

		if has('persistent_undo')
			" Save the undo tree when exiting a buffer
			set undofile
			" Number of changes that can be undone
			set undolevels=1000
			" Lines to save for undo on a buffer reload
			set undoreload=10000
		endif
	" }

" }

" Vim UI {

    " Color scheme
    let g:onedark_terminal_italics = 1
    colorscheme dracula

    " Highlight current line
    set cursorline

    " Do not show mode info in command line, have lightline for that
    set noshowmode

    " Make backspace work normally
    set backspace=indent,eol,start
    " Backspace and cursor keys wrap lines
    set whichwrap=b,s,h,l,<,>,[,]

    " Set line numbers
    set number
    set relativenumber

    " Lines to scroll when cursor leaves screen
    set scrolloff=3

    " Show matching parenthesis, etc.
    set showmatch

    " Redraw only when need to
    set lazyredraw

    " Highlight columns
    set colorcolumn=80,120

    " Use visual bell instead of beeping
    set visualbell

    " Search {
        " Search while typing
        set incsearch
        " Highlight search results
        set hlsearch
        " Search is case insensitive
        set ignorecase
        " But sensitive when uppercase letters are used
        set smartcase

        " Show list of matches instead of just completion
        set wildmenu
        set wildmode=list:longest,full
        " Recursive find
        set path+=**
        " Ignore some folders and files in find
        set wildignore+=**/node_modules/**
        set wildignore+=**/*.pyc
        set wildignore+=**/vendor/**
        set wildignore+=**/public/**
        set wildignore+=**/dist/**
        set wildignore+=**/.git/**
        set wildignore+=**/.DS_Store
    " }

    " Folding {
    
        " Enable folding, auto fold code
        set foldenable

    " }

" }

" Formatting {

    " Indent at the same level as the previous file
    set autoindent
    " Use indents of 4 spaces
    set shiftwidth=4
    " Convert tabs to spaces
    set expandtab
    " Indentation should be 4 spaces
    set tabstop=4
    " Let backspace delete indentation
    set softtabstop=4

    " Prevent inserting two spaces with J
    set nojoinspaces

    " Splits {
        " Open new splits to the right
        set splitright
        " Open new splits below
        set splitbelow
    " }

" }

" Mappings {

    " Remap leader
    let mapleader = ','
    let maplocalleader = '_'

    " Set jk to esc
    inoremap jk <esc>

    " Visual shifting (does not exit Visual mode)
    vnoremap < <gv
    vnoremap > >gv

    " Yank from the cursor to the end of the line, like C and D
    nnoremap Y y$

    " Faster scrolling
    nnoremap <C-e> 3<C-e>
    nnoremap <C-y> 3<C-y>

    " Quit the pane/buffer with <leader>q
    nnoremap <leader>q :quit<CR>
    " Save with <leader>w
    nnoremap <leader>w :w!<CR>

    " Useful mappings for managing tabs
    noremap <leader>tn :tabnew<cr>
    noremap <leader>to :tabonly<cr>
    noremap <leader>tc :tabclose<cr>
    noremap <leader>tm :tabmove
    noremap <leader>t<leader> :tabnext

    " Let 'tl' toggle between this and the last accessed tab
    let g:lasttab = 1
    nnoremap <Leader>tl :exe "tabn ".g:lasttab<CR>
    autocmd TabLeave * let g:lasttab = tabpagenr()

    " Navigation {
        " Do not move cursor with space. Useful if we want to define mappings with it.
        nnoremap <SPACE> <Nop>
        vnoremap <SPACE> <Nop>

        " Move between splits in an easier way with Ctrl-jklh
        nnoremap <C-j> <C-W>j
        nnoremap <C-k> <C-W>k
        nnoremap <C-l> <C-W>l
        nnoremap <C-h> <C-W>h

        " More comfortable jumping to marks
        nnoremap ' `
        nnoremap ` '

        " Jump to previous file with <leader><leader> (comma comma)
        nnoremap <leader><leader> <C-^>

        " Store relative line number jumps in the jumplist if they exceed a threshold.
        nnoremap <expr> k (v:count > 5 ? "m'" . v:count : '') . 'k'
        nnoremap <expr> j (v:count > 5 ? "m'" . v:count : '') . 'j'

        " Map <Leader>ff to display all lines with keyword under cursor
        " and ask which one to jump to
        " TODO: Fzf?
        nmap <Leader>ff [I:let nr = input("Which one: ")<Bar>exe "normal " . nr ."[\t"<CR>

    " }

" }

" Neovim {

    if has('nvim')

        " Set python path manually so that the boot up process is faster
        let g:python3_host_prog = '/usr/local/bin/python3'

        " Use 24-bit (true-color) mode
        let $NVIM_TUI_ENABLE_TRUE_COLOR=1

        " Nvim terminal keybindings
        tnoremap <Esc> <C-\><C-n>
        tnoremap <M-[> <Esc>
        tnoremap <C-v><Esc> <Esc>

    endif

    if (has("termguicolors"))
        set termguicolors
    endif

" }

" Functions {

    " Strip whitespace {
    function! StripTrailingWhitespace()
        " Preparation: save last search, and cursor position.
        let _s=@/
        let l = line(".")
        let c = col(".")
        " do the business:
        %s/\s\+$//e
        " clean up: restore previous search history, and cursor position
        let @/=_s
        call cursor(l, c)
    endfunction
    "}

    " Open Fzf {
    function! FZFOpen(command_str)
      if (expand('%') =~# 'NERD_tree' && winnr('$') > 1)
        exe "normal! \<c-w>\<c-w>"
      endif
      exe 'normal! ' . a:command_str . "\<cr>"
    endfunction
    " }
 
" }

